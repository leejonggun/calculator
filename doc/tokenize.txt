//Written by Joseph

token_t *Tokenize(const char *str)
	arg.str:プロンプトから読み込んだ文字列
	1.読み込んだstrを1文字ずつindexを進めながら、意味のある文字列に分割する。
	2.分割したstrをtoken_tのstrに格納する。
	3.token_tにはその他にトークンタイプ、サイズ、次のトークンへのポインタを持っていて、リスト構造になる。
	4.return値はリストの最初のポインタになる。

int pass_space(const char *input, int index)
	arg.input:プロンプトから読み込んだ文字列, index:進めた文字数
	1.スペースや改行、タブは文字列として何の意味も持っていないので飛ばす。(意味のある文字列の分割という意味があるので飛ばす)
	2.return値はスペース、改行、タブを飛ばして、次の意味のある文字列が来たらそのindexを返す。

void set_char(token_t *token, const char *buf, int count, token_type TYPE)
	arg.token:データbuf, count, TYPEを格納するためのトークン, buf:格納する文字列, count:シンタックスチェックのための数字, TYPE:トークンのタイプ
	1.文字列bufをtoken->strにstrncpyする。文字列が1文字の時使う。(カッコと演算子)
	2.token->counterにcountを格納する。対応するカッコ'('と')'のcounterを一致させて後にシンタックスチェックに使う。
	3.token->counterにcountを格納する。演算子の場合、+,-,*,/にそれぞれ0,1,2,3を割り振って関数ポインタに使う。(実装量が減る)
	4.token->ttにトークンのタイプを表すTYPEを格納する。
	5.以上でひとつの意味のある文字列を持つトークンができる
	6.return値は情報が格納された token トークン

void set_str(token_t *token, const char *buf, int buf_len, token_type TYPE)
	arg.token:データbuf, buf_len, TYPEを格納するためのトークン, buf:格納する文字列, buf_len:文字列の長さ, TYPE:トークンのタイプ
	1.文字列bufをtoken->strにstrncpyする。文字列が1文字以上の時使う。
	3.token->str_sizeにbuf_lenを格納する。
	4.token->ttにトークンのタイプを表すTYPEを格納する。
	5.以上でひとつの意味のある文字列を持つトークンができる
	6.return値は情報が格納された token トークン

token_t *token_init(token_type tt)
	arg.tt:トークンのタイプ
	1.トークンのタイプしか持たない

static int pass_space(const char *input, int index) {
	int counter = 0;
	while (input[index+counter] == ' ' || input[index+counter] == '\n' || input[index+counter] == '\t') {
		counter++;
	}
	return (index + counter);
}

token_t *Tokenize(const char *str) {
	int size, index = 0;
	int count = 0;// When token bracket, counter++. When CLOSE bracket, counter--.
	token_t *list = (token_t*)malloc(sizeof(token_t));
	token_t *root = list;
	int str_len = strlen(str);
	while (index < str_len) {
		switch (str[index]) {
			case ' ':
			case '\t':
			case '\n':
				index++;
				break;
			case '(':
				count++;
				set_char(list, &str[index], count, token);
				list->cdr = token_init(token);
				list = list->cdr;
				index++;
				break;
			case ')':
				index = pass_space(str, index);
				if (index == str_len) {
					set_char(list, &str[index], count, CLOSE);
					list->cdr = NULL;
					count--;
				} else {
					set_char(list, &str[index], count, CLOSE);
					list->cdr = token_init(CLOSE);
					list = list->cdr;
					count--;
					index++;
				}
				break;
			case '^':
				/*TODO*/
			case '!':
				/*TODO*/
			case '+':
				set_char(list, &str[index], 0, OPERATOR);
				list->cdr = token_init(OPERATOR);
				list = list->cdr;
				index++;
				break;
			case '-':
				set_char(list, &str[index], 1, OPERATOR);
				list->cdr = token_init(OPERATOR);
				list = list->cdr;
				index++;
				break;
			case '*':
				set_char(list, &str[index], 2, OPERATOR);
				list->cdr = token_init(OPERATOR);
				list = list->cdr;
				index++;
				break;
			case '/':
				set_char(list, &str[index], 3, OPERATOR);
				list->cdr = token_init(OPERATOR);
				list = list->cdr;
				index++;
				break;
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				size = 1;
				while (isdigit(str[index+size]) > 0) {
					size++;
				}
				if (str[index+size] == '.') {
					size++;
					while (isdigit(str[index+size]) > 0) {
						size++;
					}
					set_str(list, &str[index], size, DOUBLE);
				} else {
					set_str(list, &str[index], size, INT);
				}
				index += size;
				list->cdr = token_init(INT);
				list = list->cdr;
				break;
			default:
				printf("You can't input alphabet.\n");
				return NULL;
		}
	}
	if (syntax_check(root, count) == -1) {
		return NULL;
	}
	return root;
}

/*init a token to construct list & tree*/
token_t *token_init(token_type tt) {
	token_t *new = (token_t *)malloc(sizeof(token_t));
	new->tt = tt;
	new->str_size = 0;
	new->cdr = NULL;
	new->str = NULL;
	return new;
}

/*set one size charater*/
static void set_char(token_t *token, const char *buf, int count, token_type TYPE) {
	token->tt = TYPE;
	token->counter = count;
	token->str = (char *)malloc(sizeof(char) * 2);
	token->str = strncpy(token->str, buf, 1);
	token->str[1] = '\0';
}
/*set multi size token to cons list*/
static void set_str(token_t *token, const char *buf, int buf_len, token_type TYPE) {
	token->tt = TYPE;
	token->str_size = buf_len;
	token->str = (char *)malloc(sizeof(char) * (buf_len));
	token->str = strncpy(token->str, buf, buf_len);
	token->str[buf_len] = '\0';
}

/*free all tokens in list*/
void list_free(token_t *root) {
	token_t *del = root;
	switch(del->tt) {
		case token:
			while (del->cdr != NULL) {
				list_free(del->cdr);
				del = del->cdr;
			}
			break;
		case CLOSE:
		case INT:
		case DOUBLE:
		case CHAR:
		case OPERATOR:
			free(del->str);
			free(del);
			break;
	}
}
